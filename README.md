# Задача об обедающих философах

## Описание проблемы
Классическая задача синхронизации в параллельном программировании. Пять философов проводят время, чередуя размышления и приём пищи. За круглым столом стоит пять тарелок со спагетти и пять вилок. Чтобы поесть, философу нужны две вилки (левая и правая). После еды философ кладёт обе вилки и возвращается к размышлениям.

## Алгоритм решения
Используется решение Дейкстры с использованием семафоров. Каждый философ может находиться в одном из трёх состояний: думает, голоден, ест. Философ может начать есть только если оба его соседа не едят в данный момент.

## Структура программы

### Константы
- `N = 5` - количество философов
- `THINKING = 0` - состояние "размышляет"
- `HUNGRY = 1` - состояние "голоден"
- `EATING = 2` - состояние "ест"
- `MAX_MEALS = 3` - количество трапез каждого философа (для завершения программы, пусть возьмем 3)

### Макросы
- `LEFT (i-1+N)%N` - индекс левого соседа философа i
- `RIGHT (i+1)%N` - индекс правого соседа философа i

### Глобальные переменные
- `int status[N]` - массив состояний всех философов
- `sem_t mutex` - семафор для защиты критической секции (доступа к состояниям)
- `sem_t s[N]` - массив семафоров для каждого философа

## Функции

### `void Think(int i)`
Философ i размышляет случайное время от 1 до 3 секунд.

### `void Eat(int i)`
Философ i ест случайное время от 1 до 2 секунд.

### `void Check_eat(int i)`
Проверяет, может ли философ i начать есть. Условия:
1. Философ находится в состоянии HUNGRY
2. Левый сосед не ест (status[LEFT] != EATING)
3. Правый сосед не ест (status[RIGHT] != EATING)

Если все условия выполнены, меняет состояние философа на EATING и разблокирует его семафор.

### `void Take_Forks(int i)`
Процедура взятия вилок философом i:
1. Захватывает мьютекс для доступа к состояниям
2. Устанавливает состояние философа в HUNGRY
3. Вызывает Check_eat(i) для проверки возможности поесть
4. Освобождает мьютекс
5. Ожидает сигнала от своего семафора (когда можно будет есть)

### `void Put_Forks(int i)`
Процедура возврата вилок философом i:
1. Захватывает мьютекс
2. Устанавливает состояние философа в THINKING
3. Проверяет, могут ли теперь поесть его соседи (Check_eat для LEFT и RIGHT)
4. Освобождает мьютекс

### `void* Philosopher(void* arg)`
Основная функция потока-философа:
1. Получает свой идентификатор из аргумента
2. Выполняет цикл из MAX_MEALS итераций
3. В каждой итерации: думает → берёт вилки → ест → кладёт вилки

### `int main()`
Основная функция программы:
1. Инициализирует генератор случайных чисел
2. Инициализирует семафоры
3. Создаёт 5 потоков-философов
4. Ожидает завершения всех потоков
5. Уничтожает семафоры

## Механизм синхронизации

### Предотвращение deadlock
Алгоритм гарантирует отсутствие взаимной блокировки (deadlock) благодаря тому, что философ может начать есть только если оба соседа не едят. Это предотвращает ситуацию, когда все философы взяли по одной вилке и ждут вторую.

### Предотвращение starvation
Алгоритм обеспечивает справедливость: когда философ кладёт вилки, он проверяет, не могут ли теперь поесть его голодные соседи. Это гарантирует, что каждый голодный философ рано или поздно получит возможность поесть.
